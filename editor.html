<!DOCTYPE html>
<html lang="ko">

<head>
	<meta charset="UTF-8" />
	<title>하스스톤 덱 빌더</title>
	<style>
		body {
			font-family: sans-serif;
			background-color: #1e1e1e;
			color: #e0e0e0;
			margin: 0;
			padding: 20px;
		}

		h1 {
			text-align: center;
			color: #ffd700;
		}

		#mainContainer {
			display: flex;
			gap: 20px;
			margin-top: 20px;
		}

		#leftPanel {
			flex: 2;
		}

		#rightPanel {
			flex: 1;
			background: #2b2b2b;
			border-left: 2px solid #444;
			padding: 10px;
			border-radius: 10px;
		}

		#cardList {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
		}

		.card {
			border: 1px solid #555;
			padding: 10px;
			background: #3a3a3a;
			color: #fff;
			text-align: center;
			cursor: pointer;
			width: 160px;
			border-radius: 8px;
		}

		.card:hover {
			background-color: #505050;
		}

		img {
			width: 100%;
			height: auto;
			border-radius: 4px;
		}

		.pagination {
			text-align: center;
			margin: 16px 0;
		}

		.pagination button {
			margin: 0 10px;
			font-size: 18px;
			padding: 6px 12px;
			cursor: pointer;
			background-color: #444;
			color: #fff;
			border: none;
			border-radius: 5px;
		}

		.pagination button:hover {
			background-color: #666;
		}

		.page-info {
			font-size: 16px;
		}

		#deckList {
			list-style: none;
			padding: 0;
		}

		#deckList li {
			padding: 6px 0;
			border-bottom: 1px solid #555;
		}

		select {
			background-color: #2e2e2e;
			color: #fff;
			border: 1px solid #555;
			padding: 5px;
			border-radius: 4px;
		}

		label {
			font-weight: bold;
		}

		button {
			background-color: #444;
			color: #fff;
			border: none;
			padding: 6px 10px;
			margin-right: 5px;
			border-radius: 5px;
			cursor: pointer;
		}

		button:hover {
			background-color: #666;
		}
	</style>
</head>

<body>
	<h1>하스스톤 덱 빌더</h1>

	<label for="classSelect">직업 선택: </label>
	<select id="classSelect">
		<option value="MAGE">마법사</option>
		<option value="WARRIOR">전사</option>
		<option value="ROGUE">도적</option>
		<option value="PRIEST">사제</option>
		<option value="HUNTER">사냥꾼</option>
		<option value="PALADIN">성기사</option>
		<option value="SHAMAN">주술사</option>
		<option value="DRUID">드루이드</option>
		<option value="WARLOCK">흑마법사</option>
		<option value="DEMONHUNTER">악마사냥꾼</option>
		<option value="NEUTRAL">중립</option>
	</select>

	<label for="raritySelect">등급 선택: </label>
	<select id="raritySelect">
		<option value="ALL">전체</option>
		<option value="COMMON">일반</option>
		<option value="RARE">희귀</option>
		<option value="EPIC">영웅</option>
		<option value="LEGENDARY">전설</option>
	</select>

	<label for="slotSelect">덱 슬롯: </label>
	<select id="slotSelect">
		<option value="1">슬롯 1</option>
		<option value="2">슬롯 2</option>
		<option value="3">슬롯 3</option>
	</select>
	<button onclick="saveDeck()">덱 저장</button>
	<button onclick="loadDeck()">덱 불러오기</button>

	<div id="mainContainer">
		<div id="leftPanel">
			<div id="cardList"></div>
			<div class="pagination">
				<button id="prevPage">◀</button>
				<span class="page-info" id="pageInfo">1 / 1</span>
				<button id="nextPage">▶</button>
			</div>
		</div>

		<div id="rightPanel">
			<h2>현재 덱</h2>
			<div id="deckCount" style="margin-bottom: 10px;">카드 수: 0 / 30</div>
			<ul id="deckList"></ul>
		</div>
	</div>

	<script>
		let allCards = [];
		let filteredCards = [];
		let deck = [];
		let currentPage = 1;
		const cardsPerPage = 10;
		const API_URL = "https://api.hearthstonejson.com/v1/latest/koKR/cards.collectible.json";

		fetch(API_URL)
			.then(res => res.json())
			.then(data => {
				allCards = data.filter(card => (card.type === "MINION" || card.type === "SPELL") && card.cardClass);
				filterCards();
			})
			.catch(err => {
				console.error("카드 불러오기 실패:", err);
				alert("카드 데이터를 불러오는 데 실패했습니다.");
			});

		document.getElementById('classSelect').addEventListener('change', filterCards);
		document.getElementById('raritySelect').addEventListener('change', filterCards);
		document.getElementById('prevPage').addEventListener('click', () => {
			if (currentPage > 1) {
				currentPage--;
				showCards();
			}
		});
		document.getElementById('nextPage').addEventListener('click', () => {
			const totalPages = Math.ceil(filteredCards.length / cardsPerPage);
			if (currentPage < totalPages) {
				currentPage++;
				showCards();
			}
		});

		function filterCards() {
			currentPage = 1;
			const selectedClass = document.getElementById('classSelect').value;
			const selectedRarity = document.getElementById('raritySelect').value;
			filteredCards = allCards.filter(c => {
				const matchesClass = String(c.cardClass).toUpperCase() === selectedClass;
				const matchesRarity = selectedRarity === "ALL" || c.rarity === selectedRarity;
				return matchesClass && matchesRarity;
			});
			showCards();
		}

		function showCards() {
			const cardList = document.getElementById('cardList');
			cardList.innerHTML = '';
			const start = (currentPage - 1) * cardsPerPage;
			const end = start + cardsPerPage;
			const pageCards = filteredCards.slice(start, end);
			if (pageCards.length === 0) {
				cardList.innerHTML = `<p>카드가 없습니다.</p>`;
				return;
			}
			pageCards.forEach(card => {
				const div = document.createElement('div');
				div.className = 'card';
				div.innerHTML = `<strong>${card.name}</strong><br><img src="https://art.hearthstonejson.com/v1/render/latest/koKR/256x/${card.id}.png" alt="${card.name}">`;
				div.onclick = () => addToDeck(card);
				cardList.appendChild(div);
			});
			document.getElementById('pageInfo').textContent = `${currentPage} / ${Math.ceil(filteredCards.length / cardsPerPage)}`;
		}

		function addToDeck(card) {
			if (deck.length >= 30) {
				alert("덱은 최대 30장까지만 추가할 수 있습니다.");
				return;
			}
			const sameCards = deck.filter(c => c.id === card.id);
			const limit = card.rarity === "LEGENDARY" ? 1 : 2;
			if (sameCards.length < limit) {
				deck.push(card);
				updateDeck();
			} else {
				alert(`이 카드는 최대 ${limit}장까지만 추가할 수 있습니다.`);
			}
			document.getElementById('deckCount').textContent = `카드 수: ${deck.length} / 30`;
		}

		function updateDeck() {
			const list = document.getElementById('deckList');
			list.innerHTML = '';
			const cardCounts = {};
			deck.forEach(card => {
				cardCounts[card.id] = (cardCounts[card.id] || 0) + 1;
			});
			const uniqueCards = Array.from(new Set(deck.map(card => card.id)))
				.map(id => deck.find(card => card.id === id))
				.sort((a, b) => (a.cost ?? 0) - (b.cost ?? 0));
			uniqueCards.forEach(card => {
				const count = cardCounts[card.id];
				const li = document.createElement('li');
				li.textContent = `${card.name} (비용: ${card.cost ?? 0})${count > 1 ? ` (${count}장)` : ''}`;
				li.style.cursor = "pointer";
				li.onclick = () => {
					const index = deck.findIndex(c => c.id === card.id);
					if (index !== -1) {
						deck.splice(index, 1);
						updateDeck();
					}
					document.getElementById('deckCount').textContent = `카드 수: ${deck.length} / 30`;
				};
				list.appendChild(li);
			});
		}

		function getSelectedSlotKey() {
			const slot = document.getElementById('slotSelect').value;
			return `savedDeckSlot${slot}`;
		}

		function saveDeck() {
			const key = getSelectedSlotKey();
			localStorage.setItem(key, JSON.stringify(deck));
			alert(`덱이 슬롯 ${key.replace('savedDeckSlot', '')}에 저장되었습니다.`);
		}

		function loadDeck() {
			const key = getSelectedSlotKey();
			const saved = localStorage.getItem(key);
			if (saved) {
				try {
					deck = JSON.parse(saved);
					updateDeck();
					alert(`덱이 슬롯 ${key.replace('savedDeckSlot', '')}에서 불러와졌습니다.`);
				} catch (e) {
					alert("덱 불러오기에 실패했습니다.");
				}
			} else {
				alert("해당 슬롯에 저장된 덱이 없습니다.");
			}
		}
	</script>
</body>
</html>